# student/tasks.py

import openpyxl
import re
import random
import string
from celery import shared_task
from django.db import transaction
from django.contrib.auth.models import User
from .models import (
    ParentModel, ParentProfileModel, StudentModel,
    ClassesModel, ClassSectionModel, StudentSettingModel
)


def create_parent_with_user(excel_pid, import_batch_id, first_name, last_name,
                            email, mobile, occupation, residential_address):
    """
    Create a parent along with their user account and profile.
    Similar to staff creation - creates login whether or not email exists.
    """
    # Create the parent first (this will auto-generate parent_id)
    parent = ParentModel.objects.create(
        excel_pid=excel_pid,
        import_batch_id=import_batch_id,
        first_name=first_name,
        last_name=last_name,
        email=email,
        mobile=mobile,
        occupation=occupation,
        residential_address=residential_address
    )

    # Use parent_id as username (auto-generated by model)
    username = parent.parent_id

    # Check if username already exists (shouldn't happen, but safety check)
    if User.objects.filter(username=username).exists():
        print(f"WARNING: Username {username} already exists. Skipping user creation.")
        return parent

    # Check if email already exists
    if email and User.objects.filter(email=email).exists():
        print(f"WARNING: Email {email} already exists. Creating user without email.")
        email = None  # Clear email to avoid conflict

    # Generate a random password
    password = ''.join(random.choices(string.ascii_letters + string.digits, k=10))

    # Create user account
    user_fields = {
        'username': username,
        'password': password,
        'first_name': first_name,
        'last_name': last_name,
    }

    # Add email if provided and not duplicate
    if email:
        user_fields['email'] = email

    try:
        user = User.objects.create_user(**user_fields)

        # Create parent profile to link user and parent
        ParentProfileModel.objects.create(
            user=user,
            parent=parent,
            default_password=password
        )
    except Exception as e:
        print(f"ERROR creating user for parent {parent.parent_id}: {e}")
        # Parent still exists even if user creation fails

    return parent


def clean_email(email_str):
    """Extract first valid email from a string that may contain multiple emails."""
    if not email_str:
        return None

    email_str = str(email_str).strip()
    # Split by common delimiters
    emails = re.split(r'[,;\s]+', email_str)

    for email in emails:
        email = email.strip().lower()
        # Basic email validation
        if email and '@' in email and '.' in email:
            return email
    return None


def clean_phone(phone_str):
    """Extract first valid phone number from a string."""
    if not phone_str:
        return None

    phone_str = str(phone_str).strip()
    # Split by common delimiters
    phones = re.split(r'[,;]+', phone_str)

    for phone in phones:
        phone = phone.strip()
        # Remove common formatting but keep the numbers
        phone = re.sub(r'[\s\-()]', '', phone)
        if phone and len(phone) >= 10:
            return phone[:20]  # Limit to field max length
    return None


def normalize_gender(gender_str):
    """Normalize gender input to MALE/FEMALE."""
    if not gender_str:
        return None

    gender_str = str(gender_str).strip().upper()

    if gender_str in ['M', 'MALE']:
        return 'MALE'
    elif gender_str in ['F', 'FEMALE']:
        return 'FEMALE'
    return None


def find_class_by_name(class_name):
    """Find class by name (case-insensitive, first match)."""
    if not class_name:
        return None

    class_name = str(class_name).strip()
    try:
        return ClassesModel.objects.filter(name__iexact=class_name).first()
    except ClassesModel.DoesNotExist:
        return None


def find_section_by_name(section_name):
    """Find section by name (case-insensitive, first match)."""
    if not section_name:
        return None

    section_name = str(section_name).strip()
    try:
        return ClassSectionModel.objects.filter(name__iexact=section_name).first()
    except ClassSectionModel.DoesNotExist:
        return None


@shared_task
def process_parent_student_upload(parent_file_path, student_file_path, import_batch_id):
    """
    Process parent and student Excel files together.

    Args:
        parent_file_path: Path to parent Excel file
        student_file_path: Path to student Excel file
        import_batch_id: Unique identifier for this import (e.g., timestamp + filename hash)

    Returns:
        Summary string of processing results
    """
    from .models import ImportBatchModel

    try:
        # Get the import batch record
        import_batch = ImportBatchModel.objects.get(batch_id=import_batch_id)

        # Phase 1: Process Parents
        parent_results = process_parents(parent_file_path, import_batch_id)

        # Update batch with parent results
        import_batch.parents_created = parent_results['created']
        import_batch.parents_updated = parent_results['updated']
        import_batch.save(update_fields=['parents_created', 'parents_updated'])

        # Phase 2: Process Students (linked to parents via excel_pid)
        student_results = process_students(student_file_path, import_batch_id)

        # Update batch with student results and mark as completed
        import_batch.students_created = student_results['created']
        import_batch.students_updated = student_results['updated']
        import_batch.status = 'completed'
        import_batch.save(update_fields=['students_created', 'students_updated', 'status'])

        result = (
            f"PARENT IMPORT - Created: {parent_results['created']}, "
            f"Updated: {parent_results['updated']}, "
            f"Skipped: {parent_results['skipped']}, "
            f"Failed: {parent_results['failed']} | "
            f"STUDENT IMPORT - Created: {student_results['created']}, "
            f"Updated: {student_results['updated']}, "
            f"Skipped: {student_results['skipped']}, "
            f"Failed: {student_results['failed']}"
        )
        print(result)
        return result

    except ImportBatchModel.DoesNotExist:
        error_msg = f"Import batch {import_batch_id} not found"
        print(error_msg)
        return error_msg
    except Exception as e:
        error_msg = f"Critical error during import: {e}"
        print(error_msg)

        # Update batch status to failed
        try:
            import_batch = ImportBatchModel.objects.get(batch_id=import_batch_id)
            import_batch.status = 'failed'
            import_batch.error_message = str(e)
            import_batch.save(update_fields=['status', 'error_message'])
        except:
            pass

        return error_msg


def process_parents(file_path, import_batch_id):
    """Process parent Excel file."""
    created_count = 0
    updated_count = 0
    skipped_count = 0
    failed_count = 0

    try:
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        sheet = workbook.active

        # Read header row
        header_row = [cell.value for cell in sheet[1]]
        header_map = {str(header).strip().lower(): idx
                      for idx, header in enumerate(header_row) if header}

        # Process each row
        for row_index, row_cells in enumerate(sheet.iter_rows(min_row=2), start=2):
            try:
                with transaction.atomic():
                    def get_cell_value(col_name):
                        cell_index = header_map.get(col_name.lower())
                        if cell_index is None:
                            return ''
                        cell_value = row_cells[cell_index].value
                        return str(cell_value).strip() if cell_value is not None else ''

                    # Get PID (Excel ID)
                    excel_pid = get_cell_value('pid') or get_cell_value('id')
                    if not excel_pid:
                        print(f"Row {row_index}: Missing PID, skipping")
                        failed_count += 1
                        continue

                    # Get parent name
                    last_name = get_cell_value('last name') or get_cell_value('lastname')
                    first_name = get_cell_value('first name') or get_cell_value('firstname')

                    if not last_name:
                        print(f"Row {row_index}: Missing last name, skipping")
                        failed_count += 1
                        continue

                    # Clean contact info
                    email = clean_email(get_cell_value('email'))
                    mobile = clean_phone(get_cell_value('mobile') or get_cell_value('phone'))

                    # Optional fields
                    occupation = get_cell_value('occupation') or None
                    residential_address = get_cell_value('address') or get_cell_value('residential_address') or None

                    # Check if parent exists with this excel_pid and import_batch_id
                    existing_parent = ParentModel.objects.filter(
                        excel_pid=excel_pid,
                        import_batch_id=import_batch_id
                    ).first()

                    if existing_parent:
                        # Update existing parent
                        fields_to_update = []

                        if existing_parent.first_name != first_name:
                            existing_parent.first_name = first_name
                            fields_to_update.append('first_name')

                        if existing_parent.last_name != last_name:
                            existing_parent.last_name = last_name
                            fields_to_update.append('last_name')

                        if existing_parent.email != email:
                            existing_parent.email = email
                            fields_to_update.append('email')

                        if existing_parent.mobile != mobile:
                            existing_parent.mobile = mobile
                            fields_to_update.append('mobile')

                        if occupation and existing_parent.occupation != occupation:
                            existing_parent.occupation = occupation
                            fields_to_update.append('occupation')

                        if residential_address and existing_parent.residential_address != residential_address:
                            existing_parent.residential_address = residential_address
                            fields_to_update.append('residential_address')

                        if fields_to_update:
                            existing_parent.save(update_fields=fields_to_update)

                            # Also update associated user if exists
                            if hasattr(existing_parent, 'parent_profile'):
                                user = existing_parent.parent_profile.user
                                user.first_name = first_name
                                user.last_name = last_name
                                user.email = email if email else ''
                                user.save(update_fields=['first_name', 'last_name', 'email'])

                            print(f"Updated parent PID {excel_pid}: {first_name} {last_name}")
                            updated_count += 1
                        else:
                            print(f"Parent PID {excel_pid} up-to-date, skipping")
                            skipped_count += 1
                    else:
                        # Create new parent with user account
                        parent = create_parent_with_user(
                            excel_pid=excel_pid,
                            import_batch_id=import_batch_id,
                            first_name=first_name,
                            last_name=last_name,
                            email=email,
                            mobile=mobile,
                            occupation=occupation,
                            residential_address=residential_address
                        )
                        print(
                            f"Created parent PID {excel_pid}: {first_name} {last_name} (User: {parent.parent_profile.user.username})")
                        created_count += 1

            except Exception as e:
                print(f"Error processing parent row {row_index}: {e}")
                failed_count += 1

    except Exception as e:
        print(f"Error reading parent file: {e}")

    return {
        'created': created_count,
        'updated': updated_count,
        'skipped': skipped_count,
        'failed': failed_count
    }


def process_students(file_path, import_batch_id):
    """Process student Excel file and link to parents."""
    created_count = 0
    updated_count = 0
    skipped_count = 0
    failed_count = 0

    try:
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        sheet = workbook.active

        # Read header row
        header_row = [cell.value for cell in sheet[1]]
        header_map = {str(header).strip().lower(): idx
                      for idx, header in enumerate(header_row) if header}

        # Process each row
        for row_index, row_cells in enumerate(sheet.iter_rows(min_row=2), start=2):
            try:
                with transaction.atomic():
                    def get_cell_value(col_name):
                        cell_index = header_map.get(col_name.lower())
                        if cell_index is None:
                            return ''
                        cell_value = row_cells[cell_index].value
                        return str(cell_value).strip() if cell_value is not None else ''

                    # Get required fields
                    excel_pid = get_cell_value('pid') or get_cell_value('parent id')
                    first_name = get_cell_value('first name') or get_cell_value('firstname')
                    last_name = get_cell_value('last name') or get_cell_value('lastname')
                    gender_raw = get_cell_value('gender')

                    if not all([excel_pid, first_name, last_name, gender_raw]):
                        print(f"Row {row_index}: Missing required fields, skipping")
                        failed_count += 1
                        continue

                    gender = normalize_gender(gender_raw)
                    if not gender:
                        print(f"Row {row_index}: Invalid gender '{gender_raw}', skipping")
                        failed_count += 1
                        continue

                    # Find parent by excel_pid and import_batch_id
                    parent = ParentModel.objects.filter(
                        excel_pid=excel_pid,
                        import_batch_id=import_batch_id
                    ).first()

                    if not parent:
                        print(f"Row {row_index}: Parent with PID {excel_pid} not found in this import, skipping")
                        failed_count += 1
                        continue

                    # Get optional fields
                    other_name = get_cell_value('other name') or get_cell_value('othername') or ''
                    class_name = get_cell_value('class')
                    section_name = get_cell_value('arm') or get_cell_value('section')

                    # Find class and section
                    student_class = find_class_by_name(class_name)
                    class_section = find_section_by_name(section_name)

                    if class_name and not student_class:
                        print(f"Row {row_index}: Class '{class_name}' not found")
                    if section_name and not class_section:
                        print(f"Row {row_index}: Section '{section_name}' not found")

                    # Check if student exists (by name, gender, parent, and import batch)
                    existing_student = StudentModel.objects.filter(
                        first_name__iexact=first_name,
                        last_name__iexact=last_name,
                        gender=gender,
                        parent=parent,
                        import_batch_id=import_batch_id
                    ).first()

                    if existing_student:
                        # Update existing student
                        fields_to_update = []

                        if student_class and existing_student.student_class != student_class:
                            existing_student.student_class = student_class
                            fields_to_update.append('student_class')

                        if class_section and existing_student.class_section != class_section:
                            existing_student.class_section = class_section
                            fields_to_update.append('class_section')

                        if fields_to_update:
                            existing_student.save(update_fields=fields_to_update)
                            print(f"Updated student: {first_name} {last_name}")
                            updated_count += 1
                        else:
                            print(f"Student {first_name} {last_name} up-to-date, skipping")
                            skipped_count += 1
                    else:
                        # Create new student
                        StudentModel.objects.create(
                            first_name=first_name,
                            last_name=last_name,
                            gender=gender,
                            parent=parent,
                            student_class=student_class,
                            class_section=class_section,
                            import_batch_id=import_batch_id
                        )
                        print(f"Created student: {first_name} {last_name}")
                        created_count += 1

            except Exception as e:
                print(f"Error processing student row {row_index}: {e}")
                failed_count += 1

    except Exception as e:
        print(f"Error reading student file: {e}")

    return {
        'created': created_count,
        'updated': updated_count,
        'skipped': skipped_count,
        'failed': failed_count
    }